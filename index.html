
<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <title>Trailblazer API Reference</title>

    <style>
      .highlight table td { padding: 5px; }
.highlight table pre { margin: 0; }
.highlight .gh {
  color: #999999;
}
.highlight .sr {
  color: #f6aa11;
}
.highlight .go {
  color: #888888;
}
.highlight .gp {
  color: #555555;
}
.highlight .gs {
}
.highlight .gu {
  color: #aaaaaa;
}
.highlight .nb {
  color: #f6aa11;
}
.highlight .cm {
  color: #75715e;
}
.highlight .cp {
  color: #75715e;
}
.highlight .c1 {
  color: #75715e;
}
.highlight .cs {
  color: #75715e;
}
.highlight .c, .highlight .cd {
  color: #75715e;
}
.highlight .err {
  color: #960050;
}
.highlight .gr {
  color: #960050;
}
.highlight .gt {
  color: #960050;
}
.highlight .gd {
  color: #49483e;
}
.highlight .gi {
  color: #49483e;
}
.highlight .ge {
  color: #49483e;
}
.highlight .kc {
  color: #66d9ef;
}
.highlight .kd {
  color: #66d9ef;
}
.highlight .kr {
  color: #66d9ef;
}
.highlight .no {
  color: #66d9ef;
}
.highlight .kt {
  color: #66d9ef;
}
.highlight .mf {
  color: #ae81ff;
}
.highlight .mh {
  color: #ae81ff;
}
.highlight .il {
  color: #ae81ff;
}
.highlight .mi {
  color: #ae81ff;
}
.highlight .mo {
  color: #ae81ff;
}
.highlight .m, .highlight .mb, .highlight .mx {
  color: #ae81ff;
}
.highlight .sc {
  color: #ae81ff;
}
.highlight .se {
  color: #ae81ff;
}
.highlight .ss {
  color: #ae81ff;
}
.highlight .sd {
  color: #e6db74;
}
.highlight .s2 {
  color: #e6db74;
}
.highlight .sb {
  color: #e6db74;
}
.highlight .sh {
  color: #e6db74;
}
.highlight .si {
  color: #e6db74;
}
.highlight .sx {
  color: #e6db74;
}
.highlight .s1 {
  color: #e6db74;
}
.highlight .s {
  color: #e6db74;
}
.highlight .na {
  color: #a6e22e;
}
.highlight .nc {
  color: #a6e22e;
}
.highlight .nd {
  color: #a6e22e;
}
.highlight .ne {
  color: #a6e22e;
}
.highlight .nf {
  color: #a6e22e;
}
.highlight .vc {
  color: #ffffff;
}
.highlight .nn {
  color: #ffffff;
}
.highlight .nl {
  color: #ffffff;
}
.highlight .ni {
  color: #ffffff;
}
.highlight .bp {
  color: #ffffff;
}
.highlight .vg {
  color: #ffffff;
}
.highlight .vi {
  color: #ffffff;
}
.highlight .nv {
  color: #ffffff;
}
.highlight .w {
  color: #ffffff;
}
.highlight {
  color: #ffffff;
}
.highlight .n, .highlight .py, .highlight .nx {
  color: #ffffff;
}
.highlight .ow {
  color: #f92672;
}
.highlight .nt {
  color: #f92672;
}
.highlight .k, .highlight .kv {
  color: #f92672;
}
.highlight .kn {
  color: #f92672;
}
.highlight .kp {
  color: #f92672;
}
.highlight .o {
  color: #f92672;
}
    </style>
    <link href="stylesheets/screen.css" rel="stylesheet" media="screen" />
      <script src="javascripts/all.js"></script>
  </head>

  <body class="index" data-languages="[&quot;RUBY&quot;]">
    <a href="#" id="nav-button">
      <span>
        NAV
        <img src="images/navbar.png" alt="Navbar" />
      </span>
    </a>
    <div class="toc-wrapper">
      <img src="images/logo.png" class="logo" alt="Logo" />
        <div class="lang-selector">
              <a href="#" data-language-name="RUBY">RUBY</a>
        </div>
        <div class="search">
          <input type="text" class="search" id="input-search" placeholder="Search">
        </div>
        <ul class="search-results"></ul>
      <div id="toc" class="toc-list-h1">
          <li>
            <a href="#what-is-trailblazer" class="toc-h1 toc-link" data-title="what-is-trailblazer">
  
  What is Trailblazer?
</a>
          </li>
          <li>
            <a href="#activity" class="toc-h1 toc-link" data-title="activity">
  
  Activity
</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#activity-overview" class="toc-h2 toc-link" data-title="overview">
  
  Overview
</a>
                  </li>
                  <li>
                    <a href="#activity-anatomy" class="toc-h2 toc-link" data-title="anatomy">
  
  Anatomy
</a>
                  </li>
                  <li>
                    <a href="#activity-interfaces" class="toc-h2 toc-link" data-title="interfaces">
  
  Interfaces
</a>
                  </li>
                  <li>
                    <a href="#activity-composition" class="toc-h2 toc-link" data-title="composition">
  
  Composition
</a>
                  </li>
                  <li>
                    <a href="#activity-end" class="toc-h2 toc-link" data-title="end">
  
  End
</a>
                  </li>
                  <li>
                    <a href="#activity-event" class="toc-h2 toc-link" data-title="event">
  
  Event
</a>
                  </li>
                  <li>
                    <a href="#activity-wiring-api" class="toc-h2 toc-link" data-title="wiring-api">
  
  Wiring API
</a>
                  </li>
                  <li>
                    <a href="#activity-internals" class="toc-h2 toc-link" data-title="internals">
  
  Internals
</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#operation" class="toc-h1 toc-link" data-title="operation">
  
  Operation
</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#operation-operation-vs-activity" class="toc-h2 toc-link" data-title="operation-vs-activity">
  
  Operation vs. Activity
</a>
                  </li>
                  <li>
                    <a href="#operation-call" class="toc-h2 toc-link" data-title="call">
  
  Call
</a>
                  </li>
                  <li>
                    <a href="#operation-result" class="toc-h2 toc-link" data-title="result">
  
  Result
</a>
                  </li>
                  <li>
                    <a href="#operation-dsl" class="toc-h2 toc-link" data-title="dsl">
  
  DSL
</a>
                  </li>
                  <li>
                    <a href="#operation-inheritance" class="toc-h2 toc-link" data-title="inheritance">
  
  Inheritance
</a>
                  </li>
                  <li>
                    <a href="#operation-container" class="toc-h2 toc-link" data-title="container">
  
  Container
</a>
                  </li>
                  <li>
                    <a href="#operation-testing" class="toc-h2 toc-link" data-title="testing">
  
  Testing
</a>
                  </li>
                  <li>
                    <a href="#operation-debugging" class="toc-h2 toc-link" data-title="debugging">
  
  Debugging
</a>
                  </li>
                  <li>
                    <a href="#operation-dsl-sequence-options" class="toc-h2 toc-link" data-title="dsl-sequence-options">
  
  DSL: Sequence Options
</a>
                  </li>
                  <li>
                    <a href="#operation-dsl-group" class="toc-h2 toc-link" data-title="dsl-group">
  
  DSL: Group
</a>
                  </li>
                  <li>
                    <a href="#operation-patterns" class="toc-h2 toc-link" data-title="patterns">
  
  Patterns
</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#trailblazer" class="toc-h1 toc-link" data-title="trailblazer">
  
  Trailblazer
</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#trailblazer-file-structure" class="toc-h2 toc-link" data-title="file-structure">
  
  File Structure
</a>
                  </li>
                  <li>
                    <a href="#trailblazer-loader" class="toc-h2 toc-link" data-title="loader">
  
  Loader
</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#test" class="toc-h1 toc-link" data-title="test">
  
  Test
</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#test-operation-tests" class="toc-h2 toc-link" data-title="operation-tests">
  
  Operation tests
</a>
                  </li>
                  <li>
                    <a href="#test-factory" class="toc-h2 toc-link" data-title="factory">
  
  Factory
</a>
                  </li>
                  <li>
                    <a href="#test-dependency-injection" class="toc-h2 toc-link" data-title="dependency-injection">
  
  Dependency Injection
</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#workflow" class="toc-h1 toc-link" data-title="workflow">
  
  Workflow
</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#workflow-events" class="toc-h2 toc-link" data-title="events">
  
  Events
</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#endpoint" class="toc-h1 toc-link" data-title="endpoint">
  
  Endpoint
</a>
          </li>
          <li>
            <a href="#transform" class="toc-h1 toc-link" data-title="transform">
  
  Transform
</a>
          </li>
          <li>
            <a href="#reform" class="toc-h1 toc-link" data-title="reform">
  
  Reform
</a>
          </li>
          <li>
            <a href="#cells" class="toc-h1 toc-link" data-title="cells">
  
  Cells
</a>
              <ul class="toc-list-h2">
                  <li>
                    <a href="#cells-decorator" class="toc-h2 toc-link" data-title="decorator">
  
  Decorator
</a>
                  </li>
              </ul>
          </li>
          <li>
            <a href="#debugging" class="toc-h1 toc-link" data-title="debugging">
  
  Debugging
</a>
          </li>
          <li>
            <a href="#glossary" class="toc-h1 toc-link" data-title="glossary">
  
  Glossary
</a>
          </li>
      </div>
        <ul class="toc-footer">
            <li><a href='https://gitter.im/trailblazer/chat'>Gitter Chat</a></li>
            <li><a href='https://github.com/trailblazer'>Trailblazer on Github</a></li>
            <li><a href='https://github.com/lord/slate'>Documentation Powered by Slate</a></li>
        </ul>
    </div>
    <div class="page-wrapper">
      <div class="dark-box"></div>
      <div class="content">
        <h1 id="what-is-trailblazer">
  
  What is Trailblazer?
</h1>
<p>The idea of 2.1 is: If you can&#39;t draw it, you can&#39;t code it.</p>
<h1 id="activity">
  
  Activity
</h1>
<p>The activity gem provides the DSL to define workflows, and the runtime objects to execute the latter.</p>
<h2 id="activity-overview">
  
  Overview
</h2><pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Update</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>

  <span class="kp">module_function</span>
  <span class="c1">#</span>
  <span class="c1"># here goes your business logic</span>
  <span class="c1">#</span>
  <span class="k">def</span> <span class="nf">find_model</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="nb">id</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="n">ctx</span><span class="p">[</span><span class="ss">:model</span><span class="p">]</span> <span class="o">=</span> <span class="no">Memo</span><span class="p">.</span><span class="nf">find_by</span><span class="p">(</span><span class="ss">id: </span><span class="nb">id</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">params</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="k">return</span> <span class="kp">true</span> <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="ss">:body</span><span class="p">].</span><span class="nf">is_a?</span><span class="p">(</span><span class="no">String</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">params</span><span class="p">[</span><span class="ss">:body</span><span class="p">].</span><span class="nf">size</span> <span class="o">&gt;</span> <span class="mi">10</span>
    <span class="n">ctx</span><span class="p">[</span><span class="ss">:errors</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"body not long enough"</span>
    <span class="kp">false</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">model</span><span class="p">:,</span> <span class="n">params</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="n">model</span><span class="p">.</span><span class="nf">update_attributes</span><span class="p">(</span><span class="n">params</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">log_error</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">params</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="n">ctx</span><span class="p">[</span><span class="ss">:log</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"Some idiot wrote </span><span class="si">#{</span><span class="n">params</span><span class="p">.</span><span class="nf">inspect</span><span class="si">}</span><span class="s2">"</span>
  <span class="k">end</span>
  <span class="c1">#</span>
  <span class="c1"># here comes the DSL describing the layout of the activity</span>
  <span class="c1">#</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_model</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:validate</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:validation_error</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:save</span><span class="p">)</span>
  <span class="nb">fail</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:log_error</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<blockquote>
<p>Invoking an activity works via its <code>call</code> method. The <code>ctx</code> parameter can be any kind of data structure.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="n">ctx</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">id: </span><span class="mi">1</span><span class="p">,</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">body: </span><span class="s2">"Awesome!"</span> <span class="p">}</span> <span class="p">}</span>

<span class="n">event</span><span class="p">,</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Update</span><span class="o">.</span><span class="p">(</span> <span class="p">[</span><span class="n">ctx</span><span class="p">,</span> <span class="p">{}]</span> <span class="p">)</span>

</code></pre>
<blockquote>
<p>After the activity finishes, you can access computed data via the returned <code>ctx</code> object. The <code>signal</code> is the end <em>event</em> the activity stopped at.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="n">pp</span> <span class="n">ctx</span> <span class="c1">#=&gt;</span>
<span class="p">{</span><span class="ss">:id</span><span class="o">=&gt;</span><span class="mi">1</span><span class="p">,</span>
 <span class="ss">:params</span><span class="o">=&gt;</span><span class="p">{</span><span class="ss">:body</span><span class="o">=&gt;</span><span class="s2">"Awesome!"</span><span class="p">},</span>
 <span class="ss">:model</span><span class="o">=&gt;</span><span class="c1">#&lt;struct DocsActivityTest::Memo body=nil&gt;,</span>
 <span class="ss">:errors</span><span class="o">=&gt;</span><span class="s2">"body not long enough"</span><span class="p">}</span>

<span class="nb">puts</span> <span class="n">signal</span> <span class="c1">#=&gt; #&lt;Trailblazer::Activity::End semantic=:validation_error&gt;</span>

</code></pre>
<p>An activity defines a workflow for a specific business process. This can be any level of granularity, from the entire lifecycle of a user object, or validating and persisting input from a form, down to parsing and coercing a specific fragment from a document. In Trailblazer, activities are the major building block for logic.</p>

<p>Per convention, activities are <code>module</code>s and not classes. A module in Ruby is just a namespace and not automatically supposed to be used as a mixin, which we refrain from. Instead, think of an activity module as a <code>module</code> in Elixir, which is simply a collection of stateless functions. Modules have two major benefits.</p>

<ul>
<li>You can not subclass actitivies. This might sound counter-intuitive, but activity gives you the much more sustainable tool of <a href="#activity-composition">compositions</a>.</li>
<li>Modules provide <code>module_function</code> to declare every method as a class method. This makes the module more readable and allows to use <code>method</code> to attach a module method to a step.</li>
</ul>
<h3 id="activity-overview-example">
  <div><span>Overview</span></div>
  Example
</h3>
<p>In the exemplary <code>Memo::Update</code> activity, the first line extends your module and imports the DSL. Activity ships with three built-in strategies to build workflows: <code>Path</code> is designed for more linear flows, <code>Railway</code> is the <a href="https://fsharpforfunandprofit.com/rop/">railway-oriented</a> two tracks flow, and <code>FastTrack</code> is the extended railway with two more &quot;fast&quot; tracks which was tried and tested in Trailblazer for two years and more.</p>

<p>In the upper part sits the implementation of the actual steps. Note that these don&#39;t have to be located in the same module or class as the activity definition - this is just convenient in many cases. All methods expose the <em>step interface</em>, which is the default.</p>

<p>In the lower part, the actual DSL defines the activity&#39;s flow. Check out the rendered diagram, it helps to understand the DSL.</p>

<p><img src="images/activity-overview.png" ></p>

<p>The following principles apply.</p>

<ul>
<li>Each box in this diagram is called a task or step, depending on its interface, but we&#39;re not too strict here.</li>
<li>Each box - in code - is represented by a callable object you provide (usually that&#39;s a <code>method</code> as seen to the right, or another nested <code>Activity</code>).</li>
<li>Depending on the return value of the task code, the next connection is picked.</li>
<li>Per default, the <code>ctx</code> object is passed through from task to task and allows to write state.</li>
<li>An activity stops when hitting an end event.</li>
</ul>

<p>Activities are incredibly simple, even though the DSL might look very powerful. Don&#39;t worry, the DSL code is completely separated from the run-time code, and you only need to understand a handful of concepts such as task- and step interface, outputs, semantics, and colors (also known as <em>polarizations</em>) and you will be able to write and maintain more complex workflows easily.</p>
<h2 id="activity-anatomy">
  
  Anatomy
</h2>
<p>An activity is a set of tasks, with at least one start event and one or multiple end events. A task can be any Ruby callable that follows the <a href="#activity-task-interface"><em>task interface</em></a>, and it can even be another activity itself.</p>

<p><img src="images/activity-anatomy-1.png" ></p>

<p>In other words, an activity is a container, and tasks are the boxes contained in it. What you see above is actually an incorrect representation, as it doesn&#39;t name outputs or signals. We use it all the time, though, since those outputs can be inferred easily. Intuitively, you understand what this activity will do, and that the <code>save</code> task can have a successful and a failing outcome.</p>

<p><aside class="notice">We found the <a href="http://www.bpmn.org/">BPMN specification</a> to be very elegant for describing business processes, that&#39;s why Trailblazer picked up a subset of its lingo and concepts. The way we&#39;ve integrated TRB and BPMN is straight-forward, so you&#39;re not required to <a href="http://www.omg.org/spec/BPMN/2.0/PDF">read 538 pages specs</a>.</aside></p>

<p>Here&#39;s a another representation of a different activity, one that uses the above activity we just defined as a nested task.</p>

<p><img src="images/activity-anatomy-2.png" ></p>

<p>Nested activities (in BPMN they&#39;re called <em>subprocess</em>), are marked by the <code>[+]</code> symbol in the box. As you can see, both outgoing connections from the nested <code>&lt;update&gt;</code> activity need to be wired to <em>something</em> in the outer workflow. In this example, the &quot;failure&quot; output of the nested <code>&lt;update&gt;</code> activity is wired directly to the <code>End.failure</code> end event.</p>

<p>Let&#39;s look at this diagram again, with correct annotations, outputs and semantics. All those new terms will become a bit clearer in a bit.</p>

<p><img src="images/activity-anatomy-3.png" ></p>

<p>Oh, wow, that&#39;s actually more confusing. Anyway, this diagram contains all annotations used in Trailblazer&#39;s activities: outputs with semantic and signals. For a better understanding of the whole picture we should break it down to one task, first.</p>

<p><img src="images/activity-anatomy-4.png" ></p>

<blockquote>
<p>The <code>policy</code> task returning a specific signal. This is the low-level version of a task, called the <em>task interface</em>.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">def</span> <span class="nf">policy</span><span class="p">(</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flow_options</span><span class="p">),</span> <span class="o">**</span><span class="p">)</span>
  <span class="n">signal</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">[</span><span class="ss">:current_user</span><span class="p">].</span><span class="nf">nil?</span> <span class="p">?</span>
    <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Left</span> <span class="p">:</span>
    <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Right</span>

  <span class="k">return</span> <span class="n">signal</span><span class="p">,</span> <span class="p">[</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flow_options</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
<p>A task can have different outputs. Every output is defined by a <em>semantic</em> (for example <code>:success</code>) and a <em>signal</em>.</p>

<p>Both semantic and signal are completely arbitrary and you can use whatever you feel makes sense. Historically, Trailblazer uses the <code>Right</code> signal for outputs with the <code>:success</code> semantic, and <code>Left</code> for <code>:failure</code>. Also note that even the semantic (e.g. <code>:success</code>) doesn&#39;t have any meaning except for the modelling. Oh, and you&#39;re not limited to two outputs: a task may have as many outputs as you need.</p>

<p>Now, why not relate this to some code? Remember, a plain task is always a piece of Ruby code. The task can pick what output to take by returning the output&#39;s respective signal.</p>

<p><aside class="notice">Note that the terms <em>output</em> and <em>semantic</em> are inventions of Trailblazer and not part of BPMN.</aside></p>

<p>With nested activities, it&#39;s slightly different. Since the last task will be an end event, it&#39;s this very end event to decide what signal to emit. End events always <a href="#activity-event">return themselves as the signal</a>. This allows to wire a nested activity&#39;s ends to specific paths in the outer diagram, the way we&#39;ve modelled it in the example above and in the next paragraph.</p>
<h3 id="activity-anatomy-outputs-and-semantics">
  <div><span>Anatomy</span></div>
  Outputs and Semantics
</h3><pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Create</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Path</span><span class="p">()</span>

  <span class="n">task</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">),</span>
    <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">"log_error"</span>
  <span class="n">task</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:log_error</span><span class="p">),</span> <span class="ss">id: </span><span class="s2">"log_error"</span><span class="p">,</span> <span class="ss">magnetic_to: </span><span class="p">[],</span>
    <span class="no">Output</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:policy_failure</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<blockquote>
<p>Both tasks could be wired without knowing what signal they emit, just by referencing standard semantics of their outputs.</p>
</blockquote>

<p>Having defined tasks with outputs, where an output emits a specific signal, an activity modeller&#39;s job now is to specify what output gets connected to what further connection.</p>

<p>This is where the semantic of an output comes into play. A modeller can connect, say, the <code>:failure</code> output of a task with an error handler, and then with an erroring end event, without knowing about the underlying signals. This allows Trailblazer to expose a generic modelling API.</p>

<p><img src="images/activity-anatomy-5.png" ></p>

<p>All mentioned modelling concepts will be explained in detail in the following sections.</p>
<h3 id="activity-anatomy-definition">
  <div><span>Anatomy</span></div>
  Definition
</h3>
<p>SomeModule.method(:find)</p>
<h2 id="activity-interfaces">
  
  Interfaces
</h2><h3 id="activity-interfaces-call">
  <div><span>Interfaces</span></div>
  Call
</h3><h3 id="activity-interfaces-task-interface">
  <div><span>Interfaces</span></div>
  Task Interface
</h3>
<p>Memo::Find.outputs[:success]
Memo::Find.outputs[:failure]</p>
<h3 id="activity-interfaces-step-interface">
  <div><span>Interfaces</span></div>
  Step Interface
</h3><h3 id="activity-interfaces-activity-interface">
  <div><span>Interfaces</span></div>
  Activity Interface
</h3>
<p>call
outputs
to_h</p>
<h2 id="activity-composition">
  
  Composition
</h2>
<p>A main intent of Trailblazer&#39;s activities is reusability. As opposed to TRB 1.x, where inheritance was overused, we now encourage compositions. You have two tools to reuse activities with others and compose more complex workflows.</p>

<ol>
<li>The <em>Merge API</em> allows to &quot;copy&quot; activities or parts of it into others and hence merge them.</li>
<li>You can use <em>nesting</em> to call acitivies from activities and maintain cleanly encapsulated flows.</li>
</ol>
<h3 id="activity-composition-subprocess">
  <div><span>Composition</span></div>
  Subprocess
</h3>
<p>To model more complex activities and maximize reusability, a task can be an activity itself. This is called <em>nesting</em>, in BPMN, a nested activity is called <em>Subprocess</em>.</p>

<p><aside class="notice">When nesting activities, <a href="#activity-output">all mechanics from <code>Output</code></a> apply, it&#39;s just the output <em>signal</em> that is slightly different.</aside></p>
<h4 id="activity-composition-subprocess-automatic-wiring">
  <div><span>Composition /</span> Subprocess</div>
  Automatic Wiring
</h4>
<blockquote>
<p>The nested activity is a simple Railway with two ends.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Find</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:id_present?</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_model</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<blockquote>
<p>The composer is a Railway as well, and automatically &quot;understands&quot; how to wire the nested&#39;s ends.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Update</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>
  <span class="n">step</span> <span class="ss">task: </span><span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">,</span> <span class="ss">outputs: </span><span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">.</span><span class="nf">outputs</span>
<span class="k">end</span>

</code></pre>
<p>Since all activities expose the <a href="#activity-task-interface"><em>Task interface</em></a>, you can nest by simply providing the contained activity as a task.</p>

<p>When the nested activity doesn&#39;t have any custom ends, you can provide the <code>:outputs</code> option along with the nested&#39;s outputs without any need to manually reconnect. The outer Railway (the container) automatically understands how to connect the nested&#39;s ends.</p>

<p><img src="images/nested-simple-railway.png"></p>

<p>The automatic wiring of the inner activity works by matching semantics and colors: the inner <code>:success</code> end get connected to the <code>:success</code> path, the <code>:failure</code> end to the <code>:failure</code> path of the outer Railway.</p>
<h4 id="activity-composition-subprocess-manual-wiring">
  <div><span>Composition /</span> Subprocess</div>
  Manual wiring
</h4>
<blockquote>
<p>By adding two custom ends, the inner activity now has four ends.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Find</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:id_present?</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:id_missing</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_model</span><span class="p">),</span>  <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:model_not_found</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<blockquote>
<p>You can grab the nested ends&#39; outputs using <code>outputs[:semantic]</code> and wire them to custom connections.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Update</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>
  <span class="n">step</span> <span class="ss">task: </span><span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">,</span>
    <span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">.</span><span class="nf">outputs</span><span class="p">[</span><span class="ss">:success</span><span class="p">]</span>         <span class="o">=&gt;</span> <span class="no">Track</span><span class="p">(</span><span class="ss">:success</span><span class="p">),</span>
    <span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">.</span><span class="nf">outputs</span><span class="p">[</span><span class="ss">:model_not_found</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:err404</span><span class="p">),</span>
    <span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">.</span><span class="nf">outputs</span><span class="p">[</span><span class="ss">:id_missing</span><span class="p">]</span>      <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:id_missing</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>Let&#39;s assume the nested, inner activity <code>Memo::Find</code> had three ends, with specific ends to indicate what went wrong, and where (see <a href="#activity-end">End</a>). These ends have custom semantics <code>:id_present</code> and <code>:model_not_found</code> and hence can&#39;t be connected automatically. You need to manually wire them to other tasks, tracks, or ends.</p>

<p><img src="images/nested-manual-ends.png"></p>

<p>Now, all ends from the inner activity have a matching end on the outside. This helps to manage the flow better, but is not always necessary.</p>
<h4 id="activity-composition-subprocess-connect-to-color">
  <div><span>Composition /</span> Subprocess</div>
  Connect to color
</h4>
<blockquote>
<p>Instead of using <code>End</code>, you can also wire a nested output to a color, e.g. the outer <code>:failure</code> track.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Update</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>
  <span class="n">step</span> <span class="ss">task: </span><span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">,</span>
    <span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">.</span><span class="nf">outputs</span><span class="p">[</span><span class="ss">:success</span><span class="p">]</span>         <span class="o">=&gt;</span> <span class="no">Track</span><span class="p">(</span><span class="ss">:success</span><span class="p">),</span>
    <span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">.</span><span class="nf">outputs</span><span class="p">[</span><span class="ss">:model_not_found</span><span class="p">]</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:err404</span><span class="p">),</span>
    <span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">.</span><span class="nf">outputs</span><span class="p">[</span><span class="ss">:id_missing</span><span class="p">]</span>      <span class="o">=&gt;</span> <span class="no">Track</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>Sometimes, you might want to pool multiple inner ends or redirect them onto a track, instead of maintaining one end on the outside for each inner one. In this example, we redirect the <code>:id_missing</code> end to the generic <code>:failure</code> track.</p>

<p><img src="images/nested-rewire.png"></p>

<p>The <code>:id_missing</code> end is now connected to the <code>:failure</code> track, which happens to run directly into its end. Keep in mind that you can use all <a href="#activity-output">mechanics from <code>Output()</code></a> and wire nested ends to just anything.</p>
<h4 id="activity-composition-subprocess-subprocess-macro">
  <div><span>Composition /</span> Subprocess</div>
  Subprocess Macro
</h4>
<blockquote>
<p>Use the <code>Subprocess()</code> macro if you want to save typing and take advantage of <code>Output()</code>.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Update</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>
  <span class="n">step</span> <span class="no">Subprocess</span><span class="p">(</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Find</span> <span class="p">),</span>
    <span class="no">Output</span><span class="p">(</span><span class="ss">:model_not_found</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:err404</span><span class="p">),</span>
    <span class="no">Output</span><span class="p">(</span><span class="ss">:id_missing</span><span class="p">)</span>      <span class="o">=&gt;</span> <span class="no">Track</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>The <code>activity</code> gem provides the <code>Subprocess</code> macro as a short-cut when nesting activities. It will produce an identical circuit as the one above by automatically extracting and passing <code>:outputs</code> to the DSL. You may then <a href="#activity-output">use <code>Output()</code> to reference outputs</a> in a more convenient way, and without having to connect automatically matched ones.</p>
<h3 id="activity-composition-merge-api">
  <div><span>Composition</span></div>
  Merge API
</h3>
<blockquote>
<p>Use <code>merge!</code> to include an existing activity.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Update</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>

  <span class="n">merge!</span><span class="p">(</span><span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">)</span>

  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:update</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>Instead of modelling the <code>Update</code> activity as a real composition (with two separated activities and <a href="#activity-composition-subprocess">delegation via nesting</a>) you can also copy one activity directly into another. This will merge the steps into the activity, as if you had copied the merged activity where <code>merge!</code> is. In many cases, this is a fair solution that simplifies the flow.</p>

<p><img src="images/merge.png"></p>

<p>The merged activity will be embedded where you call <code>merge!</code>, as if you had copied its DSL calls to that position.</p>
<h4 id="activity-composition-merge-api-templates">
  <div><span>Composition /</span> Merge API</div>
  Templates
</h4>
<blockquote>
<p>Merged activities can contain any DSL directive.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Lib::Logger</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="nb">fail</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:log_error</span><span class="p">),</span>   <span class="ss">group: :end</span><span class="p">,</span> <span class="ss">before: </span><span class="s2">"End.failure"</span> <span class="c1"># always as last.</span>
  <span class="n">pass</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:log_success</span><span class="p">),</span> <span class="ss">group: :end</span><span class="p">,</span> <span class="ss">before: </span><span class="s2">"End.success"</span> <span class="c1"># always as last.</span>
<span class="k">end</span>

</code></pre>
<blockquote>
<p><code>merge!</code> can be used to include template activities, too.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Update</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">merge!</span> <span class="no">Lib</span><span class="o">::</span><span class="no">Logger</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>

  <span class="n">merge!</span><span class="p">(</span><span class="no">Memo</span><span class="o">::</span><span class="no">Find</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:update</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>You can use <code>merge!</code> multiple times. Note that example, the merged activity <code>Lib::Logger</code> contains <code>pass</code> and <code>fail</code> directives along with DSL options to position the tasks. If positional options are given, it doesn&#39;t matter where the <code>merge!</code> is called in the composing activity.</p>

<p><img src="images/merge-two.png"></p>

<p>This allows modeling more complex activities by composing them from multiple entities without overcomplicating the control flow by nesting them.</p>

<p><aside class="notice">In 2.1, you can finally implement &quot;template activities&quot; that define base steps that should be present in many activities at defined positions. Simply <code>merge!</code> them where needed.</aside></p>
<h2 id="activity-end">
  
  End
</h2>
<blockquote>
<p>The <code>End()</code> helper in combination with <code>Output()</code> connects an output with a newly created end.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Find</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:id_present?</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:id_missing</span><span class="p">)</span> <span class="c1"># new semantic.</span>
  <span class="c1"># step method(:find_model),  Output(:failure) =&gt; End(:failure)    # existing semantic. DOESN'T WORK, YET.</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_model</span><span class="p">),</span>  <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">"End.failure"</span>    <span class="c1"># existing end.</span>
<span class="k">end</span>

</code></pre>
<p>Outgoing connections from a task can either go to another task, or to an end event. Every strategy comes with one or more default ends, for example <code>Railway()</code> has two ends, respectively one with <code>:success</code> and one with <code>:failure</code> semantic.</p>

<p>The <code>End()</code> helper allows you to quickly connect a particular task to a new end.</p>

<p>This is incredibly helpful if further processing doesn&#39;t make sense after this task &quot;failed&quot; (or whatever made you choose hitting the new end), and you want to know &quot;what happened&quot;. For instance, a policy breach doesn&#39;t need to error out generically, but should end in a separate end with a specific semantic (e.g. <code>:policy_breach</code>). When running that activity returns the policy breach end, you know the execution stopped after the policy task.</p>

<p>On the right side, check out how to use <code>End()</code> with <code>Output()</code>.</p>

<p><aside class="warning">Note that, in order to reference an <em>existing</em> end, you currently have to use an <a href="#activity-output-id">ID reference</a>.</aside></p>

<p>The respective diagram will have three ends.</p>

<p><img src="images/end.png"></p>
<h2 id="activity-event">
  
  Event
</h2>
<blockquote>
<p>Always build end instances via the <code>End</code> builder.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="n">evt</span> <span class="o">=</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">End</span><span class="p">(</span> <span class="ss">semantic: :success_story</span> <span class="p">)</span>
</code></pre>
<blockquote>
<p>The returned signal is <code>evt</code> itself.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="n">signal</span><span class="p">,</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flow_options</span><span class="p">)</span> <span class="o">=</span> <span class="n">evt</span><span class="o">.</span><span class="p">(</span> <span class="p">[</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flow_options</span><span class="p">]</span> <span class="p">)</span>
<span class="n">signal</span> <span class="c1">#=&gt; #&lt;Trailblazer::Activity::End semantic=:success_story&gt;</span>
</code></pre>
<blockquote>
<p>Use <code>Event#to_h</code> to decompose.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="n">evt</span><span class="p">.</span><span class="nf">to_h</span> <span class="c1">#=&gt; { semantic: :success_story }</span>
</code></pre>
<p>Events are tasks with special semantics.</p>

<ul>
<li><code>Start</code> events do nothing, and always return the <code>Right</code> signal. Every activity begins with one or multiple start events.</li>
<li><code>End</code> events usually don&#39;t execute anything, either. An end event instance always returns itself as the signal. This allows to wire them to ongoing connections when nesting. End events mark the end of activity paths, and might also be used for suspending an activity as we do <a href="#workflow">in the <code>workflow</code> gem</a>.</li>
</ul>
<h2 id="activity-wiring-api">
  
  Wiring API
</h2><h3 id="activity-wiring-api-output">
  <div><span>Wiring API</span></div>
  Output
</h3>
<p>The entire DSL is only about outputs, or about connecting outputs to tasks, to be more accurate. That&#39;s why we spend a lot of time working out the best way to model activities.</p>

<!-- @nutshell -->

<p><aside class="notice">An output is mostly represented by a circle sitting on the box&#39;s edge. It is defined as a tuple of signal along with a semantic. We often write outputs in diagrams like <code>&lt;Signal&gt;:semantic</code>. The task&#39;s Ruby code can pick what output to take by returning the specific signal.</aside></p>

<p>Sometimes, we omit the circle and just annotate the outgoing arrow with the signal tuple.</p>

<blockquote>
<p>A task can return any signal with the task interface.
 The signal dictates which physical output to take.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">def</span> <span class="nf">policy</span><span class="p">(</span> <span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flow_options</span><span class="p">),</span> <span class="o">**</span><span class="p">)</span>
  <span class="n">signal</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">[</span><span class="ss">:current_user</span><span class="p">].</span><span class="nf">nil?</span> <span class="p">?</span>
    <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Left</span> <span class="p">:</span>
    <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Right</span>

  <span class="k">return</span> <span class="n">signal</span><span class="p">,</span> <span class="p">[</span><span class="n">ctx</span><span class="p">,</span> <span class="n">flow_options</span><span class="p">]</span>
<span class="k">end</span>
</code></pre>
<blockquote>
<p>The DSL automatically assigns default outputs if none are specified.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Create</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span> <span class="c1"># we're using the Railsway here</span>

  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>
  <span class="c1">#=&gt; defaults:</span>
  <span class="c1"># outputs: {</span>
  <span class="c1">#   success: Output{&lt;Right&gt;:success},</span>
  <span class="c1">#   failure: Output{&lt;Left&gt;:failure}</span>
  <span class="c1"># }</span>
<span class="k">end</span>
</code></pre>
<p><img src="images/output-versions.png" ></p>

<p>On the right-hand side, you see a <code>policy</code> task that returns either a <code>Right</code> or a <code>Left</code> signal. Remember, tasks can return just anything as a signal. Since for callable Ruby objects (which is what tasks are), there&#39;s no way to define what outputs a task comes with, it&#39;s the DSL&#39;s job to define a set of outputs of a specific task.</p>

<p>The example only works because the DSL automatically assigns outputs if none are given.</p>

<p>When using <code>task</code> or other DSL methods to add a task, depending on the strategy, the DSL will automatically provide default outputs as you see on the right. Since, now, the outputs are provided, the DSL strategy will now automatically connect the outputs to the next task.</p>

<p>For example, with <code>Path()</code>, a <code>:success</code> output will be wired to the next <code>task</code> call. In a <code>Railway</code>, the same happens, plus a <code>:failure</code> output will be connected to the error track for you.</p>

<!-- @notoc -->
<h4 id="activity-wiring-api-output-defaults-for-plain-task">
  <div><span>Wiring API /</span> Output</div>
  Defaults for Plain Task
</h4>
<blockquote>
<p>With <code>Path()</code>, the <code>task</code> method defaults <code>:outputs</code> to one <code>:success</code> output (left diagram).</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Create</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Path</span><span class="p">()</span>

  <span class="n">task</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span> <span class="c1">#, outputs: { success: Output{&lt;Right&gt;:success} }</span>
<span class="k">end</span>
</code></pre>
<blockquote>
<p>With <code>Railway()</code>, the default outputs will be <code>Right</code> and <code>Left</code> (middle diagram).</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Create</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span> <span class="c1"># we're using the Railsway here</span>

  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>
</code></pre>
<blockquote>
<p>With <code>FastTrack()</code> and the <code>fast_track: true</code> options, default outputs will be <code>Right</code>, <code>Left</code>, <code>PassFast</code> and <code>FailFast</code> (right diagram). This gives you four possible default outputs.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Create</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">FastTrack</span><span class="p">()</span> <span class="c1"># we're using the Railsway here</span>

  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">),</span> <span class="ss">fast_track: </span><span class="kp">true</span>
</code></pre>
<p>When inserting a task via the DSL, everything works identical to the behavior when <a href="#activity-output-subprocess">adding <code>Nested</code> activities</a> except for one thing: Since the DSL can&#39;t query a callable Ruby object for its outputs, it defaults the outputs as follows.</p>

<p>In a <code>Path()</code>-based activity, the <code>task</code> method always adds a <code>:success</code> output with a <code>Right</code> signal (left diagram).</p>

<p><img src="images/output-task.png" ></p>

<p>In a <code>Railway()</code> or <code>FastTrack()</code> activity, the <code>step</code> method adds <code>:success</code> and <code>:failure</code>. The latter emitting a <code>Left</code> signal (middle diagram). With <code>FastTrack</code> and the <code>:fast_track</code> option, you get up to four outputs predefined (right diagram).</p>

<p>Note that adding <code>:outputs</code> to a task doesn&#39;t mean they will be connected, it&#39;s the DSL&#39;s job now to wire those to the next task, unless you <a href="#activity-output-id">specify the connection explicitly</a>.</p>
<h4 id="activity-wiring-api-output-subprocess">
  <div><span>Wiring API /</span> Output</div>
  Subprocess
</h4>
<p>Activities can be nested. This is usually done with the <a href="#activity-composition-subprocess"><code>Subprocess</code> macro</a> that will automatically define <code>:outputs</code> for the nested activity by querying the latter via its <code>output</code> method. <code>Subprocess</code> assumes that the nested activity follows the <a href="#activity-activity-interface">Activity interface</a>.</p>

<p>Suppose the following <code>Update::Model</code> activity needs to be nested into another activity <code>Update</code>.</p>

<p><img src="images/activity-overview.png" ></p>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Update</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>

  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>
  <span class="n">step</span> <span class="no">Subprocess</span><span class="p">(</span> <span class="no">Update</span><span class="o">::</span><span class="no">Model</span> <span class="p">)</span>
    <span class="c1">#=&gt; defaults:</span>
    <span class="c1"># outputs: {</span>
    <span class="c1">#   success:            Output{&lt;Update::Right&gt;:success},</span>
    <span class="c1">#   failure:            Output{&lt;Update::Left&gt;:failure},</span>
    <span class="c1">#   failure_validation: Output{&lt;Update::ValidationErr&gt;:failure_validation},</span>
    <span class="c1"># }</span>
<span class="k">end</span>
</code></pre>
<blockquote>
<p>Non-standard semantics can be re-routed manually.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Update</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>

  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:policy</span><span class="p">)</span>
  <span class="n">step</span> <span class="no">Nested</span><span class="p">(</span> <span class="no">Update</span><span class="o">::</span><span class="no">Model</span> <span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:failure_validation</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">Track</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<p>The <code>Railway()</code> strategy will now automatically connect outputs with semantics it knows. Note that the <code>failure.validation</code> output can&#39;t be auto-connected since the semantic is unknown.</p>

<p><img src="images/nested-open.png" ></p>

<p>You need to specify that connection manually using <code>Output(:failure_validation)</code>. In the example to the right, we let the DSL take care of wiring this output to a specific task, and just say &quot;connect <code>Update</code>&#39;s validation failure output to the failure track&quot;.</p>

<p><img src="images/nested-connected-color.png" ></p>

<p>You now have two outputs going to the same next step, which is actually fine in both BPMN and Trailblazer. It&#39;s possible to <a href="#activity-output-color">rewire by color</a>, to a <a href="(#activity-output-id)">specific next task</a>, or to an <a href="#activity-output-end">existing or new end</a>.</p>
<h4 id="activity-wiring-api-output-output-option">
  <div><span>Wiring API /</span> Output</div>
  Output option
</h4><h4 id="activity-wiring-api-output-id">
  <div><span>Wiring API /</span> Output</div>
  Id
</h4>
<blockquote>
<p>Use an <code>:id</code> to reference a particular task.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">User::Signin</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_by_omniauth</span><span class="p">)</span>
  <span class="nb">fail</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_by_email</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="ss">:sign_in</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:sign_in</span><span class="p">),</span> <span class="ss">id: :sign_in</span>
  <span class="nb">fail</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:create</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>If a task needs to be connected to another specific task, you can reference the target using its ID, which will look like <code>Output(:semantic) =&gt; :id_of_target</code>. Note that the ID can be anything, but it has to be assigned on the target task.</p>

<p><img src="images/id-ref.png" ></p>

<p>In this example, if a sign in request can&#39;t be handled via Omniauth (because the user didn&#39;t attempt to sign in via Github or Facebook), the submitted email is searched, instead. If that was successful, the user is signed in.</p>

<p><aside class="notice">In operations, IDs are assigned automatically.</aside></p>
<h4 id="activity-wiring-api-output-track">
  <div><span>Wiring API /</span> Output</div>
  Track
</h4>
<blockquote>
<p>Use the <code>Track()</code> helper to reference a track.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">User::Signin</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_by_omniauth</span><span class="p">)</span>
  <span class="nb">fail</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_by_email</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">Track</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:sign_in</span><span class="p">)</span>
  <span class="nb">fail</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:create</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>Connecting tasks specifically to other tasks <a href="#activity-output-id">via IDs</a> is the right choice if you &quot;know&quot; what will be the next step. However, often, you don&#39;t want to hard-wire steps to each other but place them on tracks, and let the activity take care of connecting the tasks in the right order.</p>

<p><img src="images/id-ref.png" ></p>

<p>Here, the <code>find_by_email</code> task will have a <code>:success</code> output that will snap towards the next open <code>:success</code> input, which happens to be the input of <code>sign_in</code> (since the latter is placed <em>after</em>).</p>
<h4 id="activity-wiring-api-output-end">
  <div><span>Wiring API /</span> Output</div>
  End
</h4><h3 id="activity-wiring-api-custom-track">
  <div><span>Wiring API</span></div>
  Custom Track
</h3>
<blockquote>
<p>Use <code>magnetic_to:</code> and <code>Output()</code> to change the polarizations.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Create</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:authenticate</span><span class="p">),</span>  <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">Track</span><span class="p">(</span><span class="ss">:auth_failed</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:auth_err</span><span class="p">),</span>      <span class="ss">magnetic_to: </span><span class="p">[</span><span class="ss">:auth_failed</span><span class="p">],</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">Track</span><span class="p">(</span><span class="ss">:auth_failed</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:reset_counter</span><span class="p">),</span> <span class="ss">magnetic_to: </span><span class="p">[</span><span class="ss">:auth_failed</span><span class="p">],</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:authentication_failure</span><span class="p">)</span>

  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_model</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>All builder strategies (<code>Path</code>, <code>Railway</code>, etc.) provide defaults for outputs and track &quot;colors&quot;. These you can override, which allows to easily branch out custom tracks to handle conditionals or to model polymorphic behavior.</p>

<p><aside class="notice">Remember, <a href="#magnetism">with the Magnetic DSL</a>, tracks are a result of polarizing inputs and outputs.</aside></p>

<p>The <code>:magnetic_to</code> option is an array of polarization colors for the task&#39;s inputs (also called <em>minus pole</em>) and defines what &quot;open&quot; colors the task will &quot;snap to&quot;.</p>

<p>With <code>Output()</code>, you map outputs to colors, which is what the coming inputs will &quot;snap to&quot;. A tuple of an output and a color is called <em>plus pole</em>.</p>

<p><img src="images/custom-track.png"></p>

<p>The resulting circuit has three tracks. We didn&#39;t put anything on the <code>:failure</code> track, but it is still there. Note that, in a <code>Railway</code>, mapping the <code>:success</code> output does create the desired plus pole. However, the <code>:failure</code> output, per default, is still pointing to the <code>:failure</code> track and will result in deviation to it should <code>auth_err</code> or <code>reset_counter</code> return the <code>Left</code> signal.</p>
<h3 id="activity-wiring-api-path">
  <div><span>Wiring API</span></div>
  Path
</h3>
<blockquote>
<p>The <code>Path()</code> helper lets you build a custom track.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Create</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:authenticate</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">Path</span><span class="p">()</span> <span class="k">do</span>
    <span class="n">task</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:auth_err</span><span class="p">)</span>
    <span class="n">task</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:reset_counter</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:authentication_failure</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_model</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>Instead of having to pass around the track color of the <a href="#activity-custom-track">custom track</a>, you can use the <code>Path()</code> helper to branch out and build an additional linear flow.</p>

<p><img src="images/custom-track.png"></p>

<p>The circuit looks identical to a <a href="#activity-custom-track">custom track</a>.</p>

<p>A path will always end in an end event with a <code>:success</code> semantic, which is why the last task is explicitly connected via <code>End()</code>. This results in a track end where you define the semantic.</p>
<h4 id="activity-wiring-api-path-end-semantic">
  <div><span>Wiring API /</span> Path</div>
  End Semantic
</h4>
<blockquote>
<p>The <code>:end_semantic</code> option allows reusing the default end with a semantic you pick.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Create</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:authenticate</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">Path</span><span class="p">(</span> <span class="ss">end_semantic: :authentication_failure</span> <span class="p">)</span> <span class="k">do</span>
    <span class="n">pass</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:auth_err</span><span class="p">)</span>
    <span class="n">pass</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:reset_counter</span><span class="p">)</span>
  <span class="k">end</span>

  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_model</span><span class="p">)</span>
<span class="k">end</span>

</code></pre>
<p>The <code>Path()</code> helper accepts a <code>:end_semantic</code> option to assign a custom semantic.</p>

<p>The circuit looks identical to a <a href="#activity-custom-track">custom track</a>.</p>
<h3 id="activity-wiring-api-join">
  <div><span>Wiring API</span></div>
  Join
</h3><pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Upsert</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Path</span><span class="p">()</span>
  <span class="c1"># ...</span>

  <span class="n">task</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Left</span><span class="p">,</span> <span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">Path</span><span class="p">()</span> <span class="k">do</span>
    <span class="n">task</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Upsert</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:create</span><span class="p">)</span>
    <span class="n">task</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Upsert</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:populate</span><span class="p">),</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="s2">"save"</span>
  <span class="k">end</span>
  <span class="n">task</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:save</span><span class="p">),</span> <span class="ss">id: </span><span class="s2">"save"</span>
<span class="k">end</span>

</code></pre>
<p>An extra path can be joined with the outer activity by pointing the last (or any other) task to an existing task in the outer activity.</p>

<p><img src="images/path-join.png" ></p>

<p>Only when <code>find</code> returns the <code>Left</code> signal, the extra path is taken.</p>

<p>See also: <a href="#activity-output-id">Output: ID</a></p>
<h2 id="activity-internals">
  
  Internals
</h2>
<p>All code necessary to define and run activities is implemented in the <a href="https://github.com/trailblazer/trailblazer-operation"><code>activity</code> gem</a>. The gem consists of two completely decoupled components: declarative code for the DSL, and runtime code. We were thinking of physically separating them into <code>activity</code> and <code>activity-dsl</code>, but refrained from that step so far.</p>
<h3 id="activity-internals-dsl">
  <div><span>Internals</span></div>
  DSL
</h3>
<blockquote>
<p>The <code>Activity</code> is nothing but a DSL.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Create</span>
  <span class="kp">extend</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Activity</span><span class="o">::</span><span class="no">Railway</span><span class="p">()</span>
  <span class="c1"># ...</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:find_model</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:update</span><span class="p">)</span>
  <span class="n">step</span> <span class="nb">method</span><span class="p">(</span><span class="ss">:save</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<blockquote>
<p>The DSL creates a runtime object, called <em>circuit</em>.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="no">Create</span><span class="p">.</span><span class="nf">to_h</span><span class="p">[</span><span class="ss">:circuit</span><span class="p">]</span> <span class="c1">#=&gt; #&lt;Trailblazer::Activity::Circuit ...&gt;</span>
</code></pre>
<p>The <code>activity/dsl</code> directory contains all DSL-specific code to define activities using the declarative DSL (e.g. <code>step</code>). It also contains the <code>Activity</code> module itself, which <em>is</em> nothing but a DSL. When using the DSL in an activity or operation, a run-time object called <em>circuit</em> is created and stored.</p>

<p><aside class="notice">You don&#39;t have to use our DSL, you can simply create <code>Circuit</code> objects manually, which are a bit more than a hash along with a <a href="#activity-circuit-interface"><em>circuit interface</em></a>. You can even write your own DSL. The circuit doesn&#39;t have any clue about the DSL and how it was created.</aside></p>

<p>While the DSL code might look overwhelming at first with its <code>Builder</code> and <code>Normalizer</code> and <code>Finalizer</code>, it&#39;s actually pretty straight-forward. Huge parts of the activity code are written using activities themselves, since we needed workflows here, too. This greatly improves consistency and makes the code easier to read (and maintain).</p>
<h3 id="activity-internals-runtime">
  <div><span>Internals</span></div>
  Runtime
</h3>
<p>Goal of the <a href="#activity-dsl">DSL</a> is to make the creation of runtime objects as simple as possible for developers. It also allows to compose more complex activities from multiple components. However, it all boils down to microscopic, light-weight hash objects with a <code>call</code> method, the so called <em>circuits</em>.</p>

<p>The runtime code sits directly in the <code>activity/</code> directory.</p>

<p>A <code>Circuit</code> instance only contains flow instructions, dictating the order of the tasks to be called, what signal leads to what task, and so on. By invoking the <code>Circuit#call</code> method, this flow is launched, and it returns whatever the last task or end event returns.</p>

<p><aside class="notice">It&#39;s tremendously important to understand the separation of concerns here: a circuit has zero knowledge about the DSL, how it was created, save what is a <code>step</code>. It&#39;s a mapping hash of instructions, its goal is to invoke callable objects (your steps) in the right order.</aside></p>

<p>There are two obvious benefits from this design.</p>

<ul>
<li>In order to use and debug Trailblazer&#39;s activities, you don&#39;t have to understand the DSL code. You will only be dealing with runtime circuits, anyway.</li>
<li>The DSL is completely replaceable. If your company comes up with a next-gen way of defining circuits, it&#39;s a matter of following interfaces to swap DSLs.</li>
</ul>
<h3 id="activity-internals-magnetism">
  <div><span>Internals</span></div>
  Magnetism
</h3>
<p>bla</p>
<h1 id="operation">
  
  Operation
</h1>
<blockquote>
<p>Example for an operation that doesn&#39;t use any TRB macros. It creates a fresh <code>Memo</code> instance.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Operation</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:create_model</span>
  <span class="n">step</span> <span class="ss">:validate</span>
  <span class="n">step</span> <span class="ss">:save</span>
  <span class="n">step</span> <span class="ss">:notify</span>

  <span class="k">def</span> <span class="nf">create_model</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="o">**</span><span class="p">)</span>
    <span class="n">ctx</span><span class="p">[</span><span class="ss">:model</span><span class="p">]</span> <span class="o">=</span> <span class="no">Memo</span><span class="p">.</span><span class="nf">new</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">params</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">params</span><span class="p">[</span><span class="ss">:body</span><span class="p">].</span><span class="nf">size</span> <span class="o">&lt;</span> <span class="mi">10</span>
      <span class="n">ctx</span><span class="p">[</span><span class="ss">:errors</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"something wrong with :body"</span>
      <span class="k">return</span> <span class="kp">false</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">params</span><span class="p">:,</span> <span class="n">model</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="n">model</span><span class="p">.</span><span class="nf">body</span> <span class="o">=</span> <span class="n">params</span><span class="p">[</span><span class="ss">:body</span><span class="p">]</span>
    <span class="n">model</span><span class="p">.</span><span class="nf">save</span>
  <span class="k">end</span>

  <span class="k">def</span> <span class="nf">notify</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">model</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="no">Notifier</span><span class="o">.</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>An operation is the essential element that was introduced with the first Trailblazer book. It indeed is the most popular concept from the TRB architectural style and since has found its way into many other frameworks.</p>

<p>The goal of an operation is to encapsulate all business logic of one feature in an application. Since features (or functions) in web applications are often, very often, mapped to controller actions, sometimes operations are compared to controller actions, orchestrating all logic related to business except for HTTP-related code.</p>

<p><img src="images/action-operation.png" ></p>

<p>In particular, this means that neither HTTP code nor rendering is part of an operation.</p>
<h4 id="operation-internals-magnetism-single-entry-point">
  <div><span>Internals /</span> Magnetism</div>
  Single Entry Point
</h4>
<blockquote>
<p>The public <code>Operation.call</code> method makes invoking operations really straight-forward.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="n">result</span> <span class="o">=</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">.</span><span class="p">(</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">body: </span><span class="s2">"too short!"</span> <span class="p">}</span> <span class="p">)</span>

<span class="n">result</span><span class="p">.</span><span class="nf">success?</span>      <span class="c1">#=&gt; false</span>
<span class="n">result</span><span class="p">[</span><span class="ss">:model</span><span class="p">].</span><span class="nf">body</span>  <span class="c1">#=&gt; nil</span>
</code></pre>
<blockquote>
<p>Usually, operations are called from a controller. For example, in Rails, this could look as follows.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">MemosController</span> <span class="o">&lt;</span> <span class="no">ApplicationController</span>
  <span class="k">def</span> <span class="nf">create</span>
    <span class="n">result</span> <span class="o">=</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">.</span><span class="p">(</span> <span class="ss">params: </span><span class="n">params</span><span class="p">,</span> <span class="ss">current_user: </span><span class="n">current_user</span> <span class="p">)</span>

    <span class="k">return</span> <span class="n">redirect_to</span> <span class="s2">"/dashboard"</span> <span class="k">if</span> <span class="n">result</span><span class="p">.</span><span class="nf">success?</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>You can imagine an operation being the single entry point to invoke a function of your application such as creating a memo, viewing a comment, or generating a PDF report. The great thing about this encapsulated asset is that you can use it for different layers of your application.</p>

<ul>
<li>Operations are the single entry point in controllers.</li>
<li>They can also be used in Rake files or CLI tools, and do exactly the same as they&#39;d do in a controller.</li>
<li>Instead of factories that always create leaky test states, chains of operations are called to produce solid test scenarios that are identical to production environments.</li>
</ul>
<h2 id="operation-operation-vs-activity">
  
  Operation vs. Activity
</h2>
<p>In Trailblazer 1.x and 2.0, the <code>Operation</code> was the central notion, all was build around it. In Trailblazer 2.1, operations still exist, but they&#39;re just one piece in a huge clockwork of activities. In fact, an operation is not more than a extended API around an activity. Internally, it creates, maintains and runs an activity.</p>

<p>You could build a Trailblazer application without using <code>Trailblazer::Operation</code>. This especially makes sense when using the <code>workflow</code> process engine. However, until all applications are running with workflows, we will keep the operation like a good friend.</p>

<p>The following is different from an activity.</p>

<ul>
<li><strong>INHERITANCE</strong> An operation is a class, not a module. That means, you can use inheritance to derive subclasses. These <a href="#operation-inheritance">will inherit step methods</a> and activity wirings.</li>
<li><strong>STEP DEFINITIONS</strong> Operations provide the <code>step :some_method</code> syntax, which in turn allows to define the activity wiring <em>before</em> implementing the methods.</li>
<li><strong>CALL API</strong> When invoking an operation using <code>Create.()</code>, you have <a href="#operation-call">the &quot;convenient&quot; interface</a>: pass in <code>:params</code> and other variables, and the operation will automatically create a <code>Context</code> object. This is handy when calling an operation in a controller, or a test, but gets into your way when using an operation in a compound of other activities.</li>
<li><strong>RESULT</strong> Also, the operation <code>call</code> will return a <code>Result</code> object, whereas an activity simply returns following the <em>circuit interface</em>.</li>
<li><strong>EXTENDED RAILWAY</strong> While activities can choose their DSL strategy, an operation will always be a <code>FastTrack</code> railway with four tracks. This has been established in versions before 2.1.</li>
<li><strong>MACROS</strong> Most macros are sitting in the <code>Trailblazer::Operation</code> namespace, but you can still use them in activities.</li>
</ul>
<h2 id="operation-call">
  
  Call
</h2><pre class="highlight ruby tab-ruby"><code><span class="n">my_params</span> <span class="o">=</span> <span class="p">{</span> <span class="ss">body: </span><span class="s2">"Awesome!"</span><span class="p">,</span> <span class="ss">title: </span><span class="s2">"Eh, hi"</span> <span class="p">}</span>

<span class="n">result</span> <span class="o">=</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">.</span><span class="p">(</span>
  <span class="ss">params:       </span><span class="n">my_params</span><span class="p">,</span>
  <span class="ss">current_user: </span><span class="no">User</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="p">)</span>
</code></pre>
<p>An operation has a very convenient interface when being used in public. It is invoked with the <code>call</code> method and accepts a hash of variables. The passed tuples will automatically be converted into a <code>Trailblazer::Context</code> object that is passed through the steps as the <code>ctx</code> object.</p>
<pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Create</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:create_model</span>

  <span class="k">def</span> <span class="nf">create_model</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">current_user</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="nb">puts</span> <span class="n">ctx</span><span class="p">[</span><span class="ss">:params</span><span class="p">]</span>       <span class="c1">#=&gt; { body: "Awesome!", title: "Eh, hi" }</span>
    <span class="nb">puts</span> <span class="n">ctx</span><span class="p">[</span><span class="ss">:current_user</span><span class="p">]</span> <span class="c1">#=&gt; #&lt;User name: "Timo"&gt;</span>
    <span class="nb">puts</span> <span class="n">current_user</span>       <span class="c1">#=&gt; #&lt;User name: "Timo"&gt;</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p><aside class="notice">Note that the API has slightly changed for a better: In 2.0, the signature was <code>call(params, options)</code>, in 2.1, it is <code>call(options)</code> with one hash, only. You have to pass <code>:params</code> in this hash</aside></p>

<p>As always, in the operation&#39;s steps, you can use the <code>ctx</code> object directly plus keyword arguments. Every step receives the same <code>ctx</code> instance.</p>

<p>When <code>call</code>ing an operation, a <a href="#operation-result"><code>Result</code> object is returned</a>. This is different to the lower-level activity interface, which returns following the <em>circuit interface</em>.</p>

<p><aside class="notice">In Trailblazer 2.0, the first step argument was named <code>options</code> instead of <code>ctx</code>. This is just a convention, though, and we liked <code>ctx</code> better.</aside></p>

<p>The <code>call</code> method also accepts containers, such as a <code>dry-container</code>. Refer to the <a href="#operation-container">container section</a> to learn more about injecting additional application dependencies.</p>
<h2 id="operation-result">
  
  Result
</h2><pre class="highlight ruby tab-ruby"><code><span class="n">result</span> <span class="o">=</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">.</span><span class="p">(</span> <span class="ss">params: </span><span class="n">params</span><span class="p">,</span> <span class="ss">current_user: </span><span class="no">User</span><span class="p">.</span><span class="nf">find</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">)</span>
</code></pre>
<blockquote>
<p>You can ask about the outcome of the operation via <code>success?</code> and <code>failure?</code>.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="n">result</span><span class="p">.</span><span class="nf">success?</span> <span class="c1">#=&gt; true</span>
<span class="n">result</span><span class="p">.</span><span class="nf">failure?</span> <span class="c1">#=&gt; false</span>
</code></pre>
<blockquote>
<p>You can query the result object for all variables in <code>ctx</code>.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="n">result</span><span class="p">[</span><span class="ss">:model</span><span class="p">]</span>             <span class="c1">#=&gt; #&lt;Memo body="Awesome!"&gt;</span>
<span class="n">result</span><span class="p">[</span><span class="s2">"contract.default"</span><span class="p">]</span> <span class="c1">#=&gt; #&lt;Reform::Form ...&gt;</span>
<span class="n">result</span><span class="p">[</span><span class="ss">:current_user</span><span class="p">]</span>      <span class="c1">#=&gt; #&lt;User id=1&gt;</span>
</code></pre>
<p>The result object returned from <code>Operation.call</code> is a feature of operations, only. It simplifies the API slightly and helps to interpret the outcome of the operation in a convenient way.</p>

<p>The result object is the only way for communicating internals to the outer side, where you, the caller, sits. This is per design: Trailblazer doesn&#39;t want you to get the operation instance or any other state, because it will lead to problems.</p>

<p>Whatever is written to the <code>ctx</code> object passed from step to step will be readable via the result object. String keys and symbol keys are different. Note that macros, other steps or nested activities might have written to <code>ctx</code> as well.</p>

<p>Even though you could change state (or write) on the result object, please treat it as immutable. If you need to pass on transformed state to the rendering layer, <a href="#cells-decorator">use a decorator object</a>.</p>

<p>Again, the interpretation of the outcome is completely up to you. The result object represents what happened, and not what should happen now. For a generic way of <a href="#endpoint">interpreting results, use endpoints</a>.</p>
<h2 id="operation-dsl">
  
  DSL
</h2><pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Update</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:find_model</span><span class="p">,</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="no">End</span><span class="p">(</span><span class="ss">:model_not_found</span><span class="p">)</span>
  <span class="n">step</span> <span class="ss">:update</span>
  <span class="nb">fail</span> <span class="ss">:db_error</span>
  <span class="n">step</span> <span class="ss">:save</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre>
<p>The operation exposes a minimal DSL to create the underlying activity. An operation always maintains a <code>FastTrack</code> activity and hence allows to error out, branch, etc. The operation&#39;s DSL is <a href="#activity-fasttrack">identical to <code>Activity::FastTrack</code></a>.</p>

<p><img src="images/operation-end.png" ></p>

<p>All semantics are identical, in particular, adding steps works via <code>step</code>, <code>pass</code> and <code>fail</code>. You may use <code>:pass_fast</code>, <code>:fail_fast</code> and <code>:fast_track</code> and leverage four tracks per default.</p>

<p>Note that the step methods do not have to reside in the operation class, you can also use the <code>Module.method(:find_model)</code> trick <a href="#activity-FIXME-LINK">to compose logic</a> in operations.</p>
<h3 id="operation-dsl-id">
  <div><span>DSL</span></div>
  ID
</h3><pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Update</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="no">Finder</span><span class="p">.</span><span class="nf">method</span><span class="p">(</span><span class="ss">:find_module</span><span class="p">),</span> <span class="ss">id: </span><span class="s2">"find_module"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>
</code></pre>
<p>The DSL tries to assign valid <code>:id</code>s to every step. Make sure to set a good name for steps that you&#39;re planning to override in subclasses or when composing: this is part of your public-private API.</p>

<p>Per convention, IDs are <code>&quot;strings&quot;</code>.</p>

<!-- :override -->
<h2 id="operation-inheritance">
  
  Inheritance
</h2><h2 id="operation-container">
  
  Container
</h2><h2 id="operation-testing">
  
  Testing
</h2>
<blockquote>
<p>Example of a Minitest operation test.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="n">describe</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span> <span class="k">do</span>
  <span class="n">it</span> <span class="s2">"creates a sane Memo instance"</span> <span class="k">do</span>
    <span class="n">result</span> <span class="o">=</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">.</span><span class="p">(</span> <span class="ss">params: </span><span class="p">{</span> <span class="ss">body: </span><span class="s2">"Enjoy an IPA"</span> <span class="p">}</span> <span class="p">)</span>

    <span class="n">result</span><span class="p">.</span><span class="nf">success?</span><span class="p">.</span><span class="nf">must_equal</span> <span class="kp">true</span>
    <span class="n">result</span><span class="p">[</span><span class="ss">:model</span><span class="p">].</span><span class="nf">body</span><span class="p">.</span><span class="nf">must_equal</span> <span class="s2">"Enjoy an IPA"</span>
  <span class="k">end</span>
<span class="k">end</span>

</code></pre>
<p>The encapsulated concept of operations, or activities in general, makes them incredibly simple to test. You do exactly the same you would do in a controller: you call them.</p>

<p>By asserting the result object and making sure the side-effects are desired, you create rock-solid components that will do exactly the same in tests and in production. Also, an operation has no idea in what environment its called, allowing you to test it in Minitest, Rspec or whatever testing framework you fancy.</p>

<p>Operations can also be used as factories.</p>

<p>Check out the <a href="#test"><code>trailblazer-test</code> gem</a> for advanced testing strategies, dependency injections instead of mocking, and factory chains.</p>

<p>We&#39;re working on an RSpec adapter, too.</p>
<h2 id="operation-debugging">
  
  Debugging
</h2><h3 id="operation-debugging-tracing">
  <div><span>Debugging</span></div>
  Tracing
</h3><h3 id="operation-debugging-taskwrap">
  <div><span>Debugging</span></div>
  taskWrap
</h3><h2 id="operation-dsl-sequence-options">
  
  DSL: Sequence Options
</h2>
<p>In addition to wiring options, there are a handful of other options known as <em>sequence options</em>. They configure where a task goes when inserted, and helps with introspection and tracing.</p>

<!-- @notoc -->
<h2 id="operation-sequence-options-id">
  
  Sequence Options: id
</h2>
<blockquote>
<p>Assign names to tasks via the <code>:id</code> option, so overriding and debugging is easier.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Create</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:create_model</span><span class="p">,</span> <span class="ss">id: </span><span class="s2">"create_memo"</span>
  <span class="n">step</span> <span class="ss">:validate</span><span class="p">,</span>     <span class="ss">id: </span><span class="s2">"validate_params"</span>
  <span class="n">step</span> <span class="ss">:save</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre>
<p>You can name each step using the <code>:id</code> option. Keep in mind that names are part of your public API and should be &quot;forever&quot;.</p>

<p>This is advisable when planning to override a step via a module or inheritance or when reconnecting it. Naming also shows up in tracing and introspection. Defaults names are given to steps without the <code>:id</code> options, but these might be awkward sometimes.</p>

<blockquote>
<p>IDs can be beneficial for introspection.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span><span class="p">.</span><span class="nf">introspect</span><span class="p">(</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span> <span class="p">)</span>
<span class="c1">#=&gt; [&gt;create_memo,&gt;validate_params,&gt;save]</span>

</code></pre>
<!-- @notoc -->
<h2 id="operation-sequence-options-delete">
  
  Sequence Options: delete
</h2>
<p>When it&#39;s necessary to remove a task, you can use <code>:delete</code>.</p>
<pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">::</span><span class="no">Admin</span> <span class="o">&lt;</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span>
  <span class="n">step</span> <span class="kp">nil</span><span class="p">,</span> <span class="ss">delete: </span><span class="s2">"validate_params"</span><span class="p">,</span> <span class="ss">id: </span><span class="s2">""</span>
<span class="k">end</span>

</code></pre>
<p>The <code>:delete</code> option can be helpful when using modules or inheritance to build concrete operations from base operations. In this example, a very poor one, the <code>validate</code> task gets removed, assuming the <code>Admin</code> won&#39;t need a validation</p>
<pre class="highlight ruby tab-ruby"><code><span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span><span class="p">.</span><span class="nf">introspect</span><span class="p">(</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">::</span><span class="no">Admin</span> <span class="p">)</span>
<span class="c1">#=&gt; [&gt;create_model,&gt;save]</span>

</code></pre>
<p>All steps are inherited, then the deletion is applied, as the introspection shows.</p>

<p><img src="images/memo-delete.png"></p>

<!-- @notoc -->
<h2 id="operation-sequence-options-before">
  
  Sequence Options: before
</h2>
<p>To insert a new task before an existing one, for example in a subclass, use <code>:before</code>.</p>
<pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">::</span><span class="no">Authorized</span> <span class="o">&lt;</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span>
  <span class="n">step</span> <span class="ss">:policy</span><span class="p">,</span> <span class="ss">before: </span><span class="s2">"create_memo"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre>
<p>The circuit now yields a new <code>policy</code> step before the inherited tasks.</p>

<p><img src="images/memo-before.png"></p>

<!-- @notoc -->
<h2 id="operation-sequence-options-after">
  
  Sequence Options: after
</h2><pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">::</span><span class="no">Logging</span> <span class="o">&lt;</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span>
  <span class="n">step</span> <span class="ss">:logger</span><span class="p">,</span> <span class="ss">after: </span><span class="s2">"validate_params"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre><pre class="highlight ruby tab-ruby"><code>
<span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span><span class="p">.</span><span class="nf">introspect</span><span class="p">(</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span><span class="o">::</span><span class="no">Logging</span> <span class="p">)</span>
<span class="c1">#=&gt; [&gt;create_memo,&gt;validate_params,&gt;logger,&gt;save]</span>

</code></pre>
<p>To insert after an existing task, you might have guessed it, use the <code>:after</code> option with the exact same semantics as <code>:before</code>.</p>

<p>The task is inserted after, as the introspection shows.</p>

<!-- @notoc -->
<h2 id="operation-sequence-options-replace">
  
  Sequence Options: replace
</h2><pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Update</span> <span class="o">&lt;</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span>
  <span class="n">step</span> <span class="ss">:find_model</span><span class="p">,</span> <span class="ss">replace: </span><span class="s2">"create_memo"</span><span class="p">,</span> <span class="ss">id: </span><span class="s2">"update_memo"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre><pre class="highlight ruby tab-ruby"><code><span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span><span class="p">.</span><span class="nf">introspect</span><span class="p">(</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Update</span> <span class="p">)</span>
<span class="c1">#=&gt; [&gt;update_memo,&gt;validate_params,&gt;save]</span>

</code></pre>
<p>Replacing an existing task is done using <code>:replace</code>.</p>

<p>Replacing, obviously, only replaces in the applied class, not in the superclass.</p>
<h2 id="operation-dsl-group">
  
  DSL: Group
</h2>
<p>The <code>:group</code> option is the ideal solution to create template operations, where you declare a basic circuit layout which can then be enriched by subclasses.</p>
<pre class="highlight ruby tab-ruby"><code><span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span><span class="p">.</span><span class="nf">introspect</span><span class="p">(</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Create</span> <span class="p">)</span>
<span class="c1">#=&gt; [&gt;create_memo,&gt;validate_params,&gt;save]</span>

</code></pre><pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Operation</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:log_call</span><span class="p">,</span>  <span class="ss">group: :start</span>
  <span class="n">step</span> <span class="ss">:log_success</span><span class="p">,</span>  <span class="ss">group: :end</span><span class="p">,</span> <span class="ss">before: </span><span class="s2">"End.success"</span>
  <span class="nb">fail</span> <span class="ss">:log_errors</span><span class="p">,</span>   <span class="ss">group: :end</span><span class="p">,</span> <span class="ss">before: </span><span class="s2">"End.failure"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre>
<p>The resulting circuit, admittedly rather useless, will look as follows.</p>

<p><img src="images/group-template.png"></p>

<p>Subclasses can now insert their actual steps without any sequence options needed.</p>
<pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Create</span> <span class="o">&lt;</span> <span class="no">Memo</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:create_model</span>
  <span class="n">step</span> <span class="ss">:validate</span>
  <span class="n">step</span> <span class="ss">:save</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre>
<p>Since all logging steps defined in the template operation are placed into groups, the concrete steps sit in the middle.</p>

<p><img src="images/doormat-before.png"></p>

<p>It is perfectly fine to use the <code>:group</code> and other sequence options again, in subclasses. Also, multiple inheritance levels will work.</p>
<h2 id="operation-patterns">
  
  Patterns
</h2>
<p>no god object
only flow control
Orchestration</p>

<!-- @notoc -->
<h2 id="operation-recover">
  
  Recover
</h2><pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Upload</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:upload_to_s3</span>
  <span class="nb">fail</span> <span class="ss">:upload_to_azure</span><span class="p">,</span>  <span class="no">Output</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="ss">:success</span>
  <span class="nb">fail</span> <span class="ss">:upload_to_b2</span><span class="p">,</span>     <span class="no">Output</span><span class="p">(</span><span class="ss">:success</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="ss">:success</span>
  <span class="nb">fail</span> <span class="ss">:log_problem</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre>
<blockquote>
<p>The recover tasks themselves can now return a boolean to direct the flow.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Upload</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="c1"># ...</span>
  <span class="k">def</span> <span class="nf">upload_to_s3</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">s3</span><span class="p">:,</span> <span class="n">file</span><span class="p">:,</span> <span class="o">**</span><span class="p">)</span>
    <span class="n">s3</span><span class="p">.</span><span class="nf">upload_file</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="c1">#=&gt; returns true or false</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>
<p>Error handlers on the left track are the perfect place to &quot;fix things&quot;. This means you might want to return to the right track. We call this a <em>recover</em> task. For example, if you need to upload a file to S3, if that doesn&#39;t work, try with Azure, and if that still doesn&#39;t play, with Backblaze. This is a <a href="https://github.com/trailblazer/trailblazer/issues/190">common pattern when dealing with external APIs</a>.</p>

<p>You can simply put recover steps on the left track, and wire their <code>:success</code> output back to the right track (which the operation knows as <code>:success</code>).</p>

<p>The resulting circuit looks as follows.</p>

<p><img src="images/recover.png"></p>

<p>The <code>Output(:success)</code> DSL call will find the task&#39;s <code>:success</code>-colored output and connect it to the right (<code>:success</code>) track.</p>

<!-- @notoc -->
<h2 id="operation-decider">
  
  Decider
</h2><pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Upsert</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:find_model</span><span class="p">,</span> <span class="no">Output</span><span class="p">(</span><span class="ss">:failure</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="ss">:create_route</span>
  <span class="n">step</span> <span class="ss">:update</span>
  <span class="n">step</span> <span class="ss">:create</span><span class="p">,</span> <span class="ss">magnetic_to: </span><span class="p">[</span><span class="ss">:create_route</span><span class="p">]</span>
  <span class="n">step</span> <span class="ss">:save</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre>
<p>If you want to stay on one path but need to branch-and-return to model a decision, use the decider pattern.</p>

<p>In this example, the success track from <code>find_model</code> will go to <code>update</code> whereas the <code>failure</code> output gets connected to <code>create</code>, giving the circuit a diamond-shaped flow.</p>

<p><img src="images/decider.png"></p>

<p>Note that we&#39;re using properties of the <em>magnetic</em> API here: by polarizing (or <em>coloring</em>) the <code>failure</code> output of <code>find_model</code> to <code>:create_route</code> (which is a random name we picked), and making <code>create</code> being attracted to that very polarization, the failure output &quot;snaps&quot; to that task automatically.</p>

<p>The cool feature with the magnetic API in this example is that you don&#39;t need to know what is the specific target of a connection, allowing to push multiple tasks onto that new <code>:create_route</code> track, if you needed that.</p>

<!-- @notoc -->
<h2 id="operation-doormat-step">
  
  Doormat Step
</h2>
<p>Very often, you want to have one or multiple &quot;last steps&quot; in an operation, for instance to generically log errors or success messages. We call this a <em>doormat step</em>.</p>
<h3 id="operation-doormat-step-doormat-step-before">
  <div><span>Doormat Step</span></div>
  Doormat Step: Before
</h3><pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Create</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:create_model</span>
  <span class="n">step</span> <span class="ss">:log_success</span>

  <span class="n">step</span> <span class="ss">:validate</span><span class="p">,</span> <span class="ss">before: :log_success</span>
  <span class="n">step</span> <span class="ss">:save</span><span class="p">,</span>     <span class="ss">before: :log_success</span>

  <span class="nb">fail</span> <span class="ss">:log_errors</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre>
<p>The most elementary way to achieve this is using the <code>:before</code> option.</p>

<p>Note that <code>:before</code> is a DSL option and not exactly related to the wiring API. Using this option, the inserted step will be &quot;moved up&quot; as if you had actually called it before the targeted <code>:before</code> step.</p>

<p><img src="images/doormat-before.png"></p>
<h3 id="operation-doormat-step-doormat-step-group">
  <div><span>Doormat Step</span></div>
  Doormat Step: Group
</h3><pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Create</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="n">step</span> <span class="ss">:create_model</span>
  <span class="n">step</span> <span class="ss">:log_success</span><span class="p">,</span>  <span class="ss">group: :end</span><span class="p">,</span> <span class="ss">before: </span><span class="s2">"End.success"</span>

  <span class="n">step</span> <span class="ss">:validate</span>
  <span class="n">step</span> <span class="ss">:save</span>

  <span class="nb">fail</span> <span class="ss">:log_errors</span><span class="p">,</span>   <span class="ss">group: :end</span><span class="p">,</span> <span class="ss">before: </span><span class="s2">"End.failure"</span>
  <span class="c1"># ...</span>
<span class="k">end</span>

</code></pre>
<p>An easier way to place particular steps always into the end section is to use the <code>:group</code> option.</p>

<p>The resulting <code>Memo::Create</code>&#39;s circuit is identical to the <a href="#doormat-step-before">last example</a>.</p>

<p>Note how this can be used for <a href="#group">&quot;template operations&quot;</a> where the inherited class really only adds its concrete steps into the existing layout.</p>
<h1 id="trailblazer">
  
  Trailblazer
</h1>
<aside class="notice">
  Populate me
</aside>
<h2 id="trailblazer-file-structure">
  
  File Structure
</h2><h2 id="trailblazer-loader">
  
  Loader
</h2>
<blockquote>
<p>Short-form, needs our loader.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">class</span> <span class="nc">Memo</span><span class="o">::</span><span class="no">Create</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
<span class="k">end</span>
</code></pre>
<blockquote>
<p>Normal, works with Rails autoloader out-of-the-box.</p>
</blockquote>
<pre class="highlight ruby tab-ruby"><code><span class="k">module</span> <span class="nn">Memo::Operation</span>
  <span class="k">class</span> <span class="nc">Create</span> <span class="o">&lt;</span> <span class="no">Trailblazer</span><span class="o">::</span><span class="no">Operation</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre><h3 id="trailblazer-loader-disable-loader">
  <div><span>Loader</span></div>
  Disable Loader
</h3><pre class="highlight ruby tab-ruby"><code><span class="no">Memos</span><span class="o">::</span><span class="no">Application</span><span class="p">.</span><span class="nf">config</span><span class="p">.</span><span class="nf">trailblazer</span><span class="p">.</span><span class="nf">use_loader</span> <span class="o">=</span> <span class="kp">false</span>
</code></pre>
<p>In Rails, the <code>Trailblazer::Loader</code> is only necessary when you want to use the short-form for operations. You can disable our loader entirely should you follow the <a href="http://guides.rubyonrails.org/autoloading_and_reloading_constants.html">Rails naming conventions</a>.</p>
<h1 id="test">
  
  Test
</h1><h2 id="test-operation-tests">
  
  Operation tests
</h2><h2 id="test-factory">
  
  Factory
</h2><h2 id="test-dependency-injection">
  
  Dependency Injection
</h2><h1 id="workflow">
  
  Workflow
</h1>
<aside class="notice">
Please note that the `workflow` gem and its process engine can only be used by subscribing to a PRO or ENTERPRISE plan.
</aside>
<h2 id="workflow-events">
  
  Events
</h2>
<p>In Trailblazer, triggering a throwing event via the process engine always implies resuming a process that was stopped earlier. It resumes at the resume event, which is a <em>catching event</em>.</p>
<h3 id="workflow-events-explicit-event">
  <div><span>Events</span></div>
  Explicit Event
</h3><pre class="highlight ruby tab-ruby"><code><span class="p">{</span>
  <span class="ss">uuid: </span><span class="s2">"66f1f0b1-7fe0-46b9-85dd-37dcea3fde51"</span><span class="p">,</span>
  <span class="ss">resume_path: </span><span class="p">[</span><span class="ss">:ready_for_sign_in</span><span class="p">,</span> <span class="ss">:user_resume</span><span class="p">],</span>
  <span class="ss">data: </span><span class="p">{</span>
    <span class="ss">user_id: </span><span class="mi">1</span><span class="p">,</span>
    <span class="ss">group_id: </span><span class="mi">2</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
<blockquote>
<p>Example of an explicit event that gets persisted to be triggered at a later point in time.</p>
</blockquote>

<p>You can let Trailblazer maintain all open (or triggerable) events instead of managing state yourself. Every throwing event is persisted (Mysql, Postgres, Redis, etc), those who know the event UUID can trigger this event and continue the session, potentially avoiding permission checks and authentication.</p>

<p>Per default, the process engine will assume it&#39;s &quot;ok&quot; to continue from the throwing event.</p>

<p>A setup with explicit events emulates a persistent environment, where a process runs in a &quot;real&quot; state machine from beginning to end. This is found in many Java BPMN implementations. In Trailblazer, whatsoever, until we implement a persistend process engine, we decided this semi-persistent setup is extremely flexible, quite fast and a good trade-off.</p>

<p>An explicit event is always an instance of <code>Event::Throwing</code>.</p>
<h3 id="workflow-events-implicit-event">
  <div><span>Events</span></div>
  Implicit Event
</h3><pre class="highlight ruby tab-ruby"><code><span class="no">Trailblazer</span><span class="o">::</span><span class="no">Workflow</span><span class="o">::</span><span class="no">Event</span><span class="p">.</span><span class="nf">implicit</span><span class="p">(</span>
  <span class="p">[</span><span class="ss">:ready_for_signin</span><span class="p">],</span>
  <span class="p">{</span> <span class="ss">user_id: </span><span class="n">user</span><span class="p">.</span><span class="nf">id</span> <span class="p">}</span>
<span class="p">)</span>
</code></pre>
<blockquote>
<p>Example for creating an ad-hoc event instance.</p>
</blockquote>

<p>In case you&#39;re migrating from a legacy app, or simply don&#39;t want to maintain another table for sessions, events can also be inferred ad-hoc, for example in a controller action. The event data and state can be computed from arbitrary (persisted) data. This is called an <em>implicit event</em>.</p>

<p>Every implicit event is an instance of <code>Event::Throwing</code>.</p>
<h1 id="endpoint">
  
  Endpoint
</h1>
<aside class="notice">
  Populate me
</aside>
<h1 id="transform">
  
  Transform
</h1>
<aside class="notice">
  Populate me
</aside>
<h1 id="reform">
  
  Reform
</h1>
<aside class="notice">
  Discuss when to use reform, and how it's being replaced by transform
</aside>
<h1 id="cells">
  
  Cells
</h1>
<aside class="notice">
  Populate me
</aside>
<h2 id="cells-decorator">
  
  Decorator
</h2><h1 id="debugging">
  
  Debugging
</h1>
<aside class="notice">
  Best practices for debugging TRB apps. Also trailblazer-developer when it's ready.
</aside>
<h1 id="glossary">
  
  Glossary
</h1>
<aside class="notice">

</aside>
<h4 id="glossary-decorator-implicit-event-test">
  <div><span>Decorator /</span> Implicit Event</div>
  Test
</h4>
      </div>
      <div class="dark-box">
          <div class="lang-selector">
                <a href="#" data-language-name="RUBY">RUBY</a>
          </div>
      </div>
    </div>
  </body>
</html>
